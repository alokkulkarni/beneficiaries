/**
 * Generated by GitHub Copilot Agent
 * Issue: #0
 * Date: 2025-12-18
 * NOTE: This test was auto-generated. Review and modify as needed.
 */
package com.alok.payment.beneficiaries.unit.service;

import com.alok.payment.beneficiaries.dto.BeneficiarySearchCriteria;
import com.alok.payment.beneficiaries.dto.PagedResponse;
import com.alok.payment.beneficiaries.model.Beneficiary;
import com.alok.payment.beneficiaries.repository.BeneficiaryRepository;
import com.alok.payment.beneficiaries.service.BeneficiaryService;
import com.alok.payment.beneficiaries.service.BeneficiaryValidationService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("BeneficiaryService Search and Analytics Unit Tests")
class BeneficiaryServiceSearchAnalyticsTest {
    
    @Mock
    private BeneficiaryRepository beneficiaryRepository;
    
    @Mock
    private BeneficiaryValidationService validationService;
    
    @InjectMocks
    private BeneficiaryService beneficiaryService;
    
    private List<Beneficiary> testBeneficiaries;
    private BeneficiarySearchCriteria searchCriteria;

    @BeforeEach
    void setUp() {
        LocalDateTime now = LocalDateTime.now();
        
        Beneficiary b1 = new Beneficiary();
        b1.setId(1L);
        b1.setCustomerId("CUST001");
        b1.setAccountNumber("ACC001");
        b1.setBeneficiaryName("John Doe");
        b1.setBeneficiaryAccountNumber("BEN001");
        b1.setBeneficiaryBankCode("BANK001");
        b1.setBeneficiaryBankName("Test Bank 1");
        b1.setBeneficiaryType("DOMESTIC");
        b1.setStatus("ACTIVE");
        b1.setCreatedAt(now.minusDays(10));
        b1.setUpdatedAt(now);

        Beneficiary b2 = new Beneficiary();
        b2.setId(2L);
        b2.setCustomerId("CUST001");
        b2.setAccountNumber("ACC001");
        b2.setBeneficiaryName("Jane Smith");
        b2.setBeneficiaryAccountNumber("BEN002");
        b2.setBeneficiaryBankCode("BANK002");
        b2.setBeneficiaryBankName("Test Bank 2");
        b2.setBeneficiaryType("INTERNATIONAL");
        b2.setStatus("ACTIVE");
        b2.setCreatedAt(now.minusDays(5));
        b2.setUpdatedAt(now);

        Beneficiary b3 = new Beneficiary();
        b3.setId(3L);
        b3.setCustomerId("CUST001");
        b3.setAccountNumber("ACC001");
        b3.setBeneficiaryName("Bob Johnson");
        b3.setBeneficiaryAccountNumber("BEN003");
        b3.setBeneficiaryBankCode("BANK001");
        b3.setBeneficiaryBankName("Test Bank 1");
        b3.setBeneficiaryType("DOMESTIC");
        b3.setStatus("INACTIVE");
        b3.setCreatedAt(now.minusDays(2));
        b3.setUpdatedAt(now);

        testBeneficiaries = Arrays.asList(b1, b2, b3);

        searchCriteria = new BeneficiarySearchCriteria();
        searchCriteria.setCustomerId("CUST001");
        searchCriteria.setPage(0);
        searchCriteria.setSize(10);
        searchCriteria.setSortBy("createdAt");
        searchCriteria.setSortDirection("DESC");
    }

    @Test
    @DisplayName("Should search beneficiaries with criteria and return paged response")
    void shouldSearchBeneficiariesWithCriteria() {
        // Given
        when(beneficiaryRepository.searchBeneficiaries(
                eq("CUST001"), any(), any(), any(), any(), any(), any(),
                eq("createdAt"), eq("DESC"), eq(10), eq(0)
        )).thenReturn(testBeneficiaries);
        when(beneficiaryRepository.countBeneficiaries(
                eq("CUST001"), any(), any(), any(), any(), any(), any()
        )).thenReturn(3L);

        // When
        PagedResponse<Beneficiary> result = beneficiaryService.searchBeneficiaries(searchCriteria);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getContent()).hasSize(3);
        assertThat(result.getPage()).isEqualTo(0);
        assertThat(result.getSize()).isEqualTo(10);
        assertThat(result.getTotalElements()).isEqualTo(3);
        assertThat(result.getTotalPages()).isEqualTo(1);
        assertThat(result.isFirst()).isTrue();
        assertThat(result.isLast()).isTrue();

        verify(beneficiaryRepository).searchBeneficiaries(
                eq("CUST001"), any(), any(), any(), any(), any(), any(),
                eq("createdAt"), eq("DESC"), eq(10), eq(0)
        );
        verify(beneficiaryRepository).countBeneficiaries(
                eq("CUST001"), any(), any(), any(), any(), any(), any()
        );
    }

    @Test
    @DisplayName("Should search beneficiaries with name filter")
    void shouldSearchBeneficiariesWithNameFilter() {
        // Given
        searchCriteria.setBeneficiaryName("John");
        List<Beneficiary> filteredList = Arrays.asList(testBeneficiaries.get(0));
        
        when(beneficiaryRepository.searchBeneficiaries(
                eq("CUST001"), eq("John"), any(), any(), any(), any(), any(),
                any(), any(), anyInt(), anyInt()
        )).thenReturn(filteredList);
        when(beneficiaryRepository.countBeneficiaries(
                eq("CUST001"), eq("John"), any(), any(), any(), any(), any()
        )).thenReturn(1L);

        // When
        PagedResponse<Beneficiary> result = beneficiaryService.searchBeneficiaries(searchCriteria);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getContent()).hasSize(1);
        assertThat(result.getTotalElements()).isEqualTo(1);
        assertThat(result.getContent().get(0).getBeneficiaryName()).isEqualTo("John Doe");
    }

    @Test
    @DisplayName("Should search beneficiaries with type filter")
    void shouldSearchBeneficiariesWithTypeFilter() {
        // Given
        searchCriteria.setBeneficiaryType("INTERNATIONAL");
        List<Beneficiary> filteredList = Arrays.asList(testBeneficiaries.get(1));
        
        when(beneficiaryRepository.searchBeneficiaries(
                eq("CUST001"), any(), eq("INTERNATIONAL"), any(), any(), any(), any(),
                any(), any(), anyInt(), anyInt()
        )).thenReturn(filteredList);
        when(beneficiaryRepository.countBeneficiaries(
                eq("CUST001"), any(), eq("INTERNATIONAL"), any(), any(), any(), any()
        )).thenReturn(1L);

        // When
        PagedResponse<Beneficiary> result = beneficiaryService.searchBeneficiaries(searchCriteria);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getContent()).hasSize(1);
        assertThat(result.getContent().get(0).getBeneficiaryType()).isEqualTo("INTERNATIONAL");
    }

    @Test
    @DisplayName("Should search beneficiaries with pagination")
    void shouldSearchBeneficiariesWithPagination() {
        // Given
        searchCriteria.setPage(1);
        searchCriteria.setSize(2);
        
        List<Beneficiary> page2List = Arrays.asList(testBeneficiaries.get(2));
        
        when(beneficiaryRepository.searchBeneficiaries(
                any(), any(), any(), any(), any(), any(), any(),
                any(), any(), eq(2), eq(2)
        )).thenReturn(page2List);
        when(beneficiaryRepository.countBeneficiaries(
                any(), any(), any(), any(), any(), any(), any()
        )).thenReturn(3L);

        // When
        PagedResponse<Beneficiary> result = beneficiaryService.searchBeneficiaries(searchCriteria);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getContent()).hasSize(1);
        assertThat(result.getPage()).isEqualTo(1);
        assertThat(result.getSize()).isEqualTo(2);
        assertThat(result.getTotalPages()).isEqualTo(2);
        assertThat(result.isFirst()).isFalse();
        assertThat(result.isLast()).isTrue();
    }

    @Test
    @DisplayName("Should get customer beneficiary analytics")
    void shouldGetCustomerBeneficiaryAnalytics() {
        // Given
        when(beneficiaryRepository.findByCustomerId("CUST001")).thenReturn(testBeneficiaries);

        // When
        Map<String, Object> analytics = beneficiaryService.getCustomerBeneficiaryAnalytics("CUST001");

        // Then
        assertThat(analytics).isNotNull();
        assertThat(analytics.get("customerId")).isEqualTo("CUST001");
        assertThat(analytics.get("totalBeneficiaries")).isEqualTo(3);
        assertThat(analytics.get("activeBeneficiaries")).isEqualTo(2L);
        assertThat(analytics.get("inactiveBeneficiaries")).isEqualTo(1L);
        
        @SuppressWarnings("unchecked")
        Map<String, Long> byType = (Map<String, Long>) analytics.get("beneficiariesByType");
        assertThat(byType).isNotNull();
        assertThat(byType.get("DOMESTIC")).isEqualTo(2L);
        assertThat(byType.get("INTERNATIONAL")).isEqualTo(1L);
        
        @SuppressWarnings("unchecked")
        Map<String, Long> byBank = (Map<String, Long>) analytics.get("beneficiariesByBank");
        assertThat(byBank).isNotNull();
        assertThat(byBank.get("Test Bank 1")).isEqualTo(2L);
        assertThat(byBank.get("Test Bank 2")).isEqualTo(1L);
        
        assertThat(analytics.get("mostRecentBeneficiaryName")).isEqualTo("Bob Johnson");
        assertThat(analytics.get("mostRecentAddedAt")).isNotNull();

        verify(beneficiaryRepository).findByCustomerId("CUST001");
    }

    @Test
    @DisplayName("Should handle empty beneficiary list in analytics")
    void shouldHandleEmptyBeneficiaryListInAnalytics() {
        // Given
        when(beneficiaryRepository.findByCustomerId("CUST999")).thenReturn(Arrays.asList());

        // When
        Map<String, Object> analytics = beneficiaryService.getCustomerBeneficiaryAnalytics("CUST999");

        // Then
        assertThat(analytics).isNotNull();
        assertThat(analytics.get("totalBeneficiaries")).isEqualTo(0);
        assertThat(analytics.get("activeBeneficiaries")).isEqualTo(0L);
        assertThat(analytics.get("inactiveBeneficiaries")).isEqualTo(0L);
        assertThat(analytics.get("mostRecentBeneficiaryName")).isNull();
    }

    @Test
    @DisplayName("Should find potential duplicates based on name similarity")
    void shouldFindPotentialDuplicates() {
        // Given
        Beneficiary b1 = new Beneficiary();
        b1.setId(1L);
        b1.setBeneficiaryName("John Doe");
        b1.setBeneficiaryAccountNumber("ACC001");
        
        Beneficiary b2 = new Beneficiary();
        b2.setId(2L);
        b2.setBeneficiaryName("JohnDoe");
        b2.setBeneficiaryAccountNumber("ACC002");
        
        when(beneficiaryRepository.findByCustomerId("CUST001"))
                .thenReturn(Arrays.asList(b1, b2));

        // When
        List<Map<String, Object>> duplicates = beneficiaryService.findPotentialDuplicates("CUST001");

        // Then
        assertThat(duplicates).isNotEmpty();
        assertThat(duplicates).anySatisfy(dup -> {
            assertThat(dup.get("beneficiary1Id")).isIn(1L, 2L);
            assertThat(dup.get("beneficiary2Id")).isIn(1L, 2L);
            assertThat(dup.get("similarity")).isEqualTo("HIGH");
        });

        verify(beneficiaryRepository).findByCustomerId("CUST001");
    }

    @Test
    @DisplayName("Should not find duplicates for distinct names")
    void shouldNotFindDuplicatesForDistinctNames() {
        // Given
        Beneficiary b1 = new Beneficiary();
        b1.setId(1L);
        b1.setBeneficiaryName("Alice Anderson");
        b1.setBeneficiaryAccountNumber("ACC001");
        
        Beneficiary b2 = new Beneficiary();
        b2.setId(2L);
        b2.setBeneficiaryName("Zara Zhang");
        b2.setBeneficiaryAccountNumber("ACC002");
        
        when(beneficiaryRepository.findByCustomerId("CUST001"))
                .thenReturn(Arrays.asList(b1, b2));

        // When
        List<Map<String, Object>> duplicates = beneficiaryService.findPotentialDuplicates("CUST001");

        // Then
        assertThat(duplicates).isEmpty();
    }

    @Test
    @DisplayName("Should generate beneficiary usage report for time period")
    void shouldGenerateBeneficiaryUsageReport() {
        // Given
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime startDate = now.minusDays(7);
        LocalDateTime endDate = now;
        
        when(beneficiaryRepository.findByCustomerId("CUST001")).thenReturn(testBeneficiaries);

        // When
        Map<String, Object> report = beneficiaryService.getBeneficiaryUsageReport(
                "CUST001", startDate, endDate);

        // Then
        assertThat(report).isNotNull();
        assertThat(report.get("customerId")).isEqualTo("CUST001");
        assertThat(report.get("reportPeriodStart")).isEqualTo(startDate);
        assertThat(report.get("reportPeriodEnd")).isEqualTo(endDate);
        assertThat(report.get("totalBeneficiaries")).isEqualTo(3);
        assertThat(report.get("beneficiariesAddedInPeriod")).isInstanceOf(Integer.class);
        assertThat(report.get("growthRatePercent")).isInstanceOf(Double.class);

        verify(beneficiaryRepository).findByCustomerId("CUST001");
    }

    @Test
    @DisplayName("Should calculate growth rate correctly in usage report")
    void shouldCalculateGrowthRateCorrectly() {
        // Given
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime startDate = now.minusDays(7);
        LocalDateTime endDate = now;
        
        // All beneficiaries created within period
        List<Beneficiary> allInPeriod = testBeneficiaries.stream()
                .peek(b -> b.setCreatedAt(now.minusDays(3)))
                .toList();
        
        when(beneficiaryRepository.findByCustomerId("CUST001")).thenReturn(allInPeriod);

        // When
        Map<String, Object> report = beneficiaryService.getBeneficiaryUsageReport(
                "CUST001", startDate, endDate);

        // Then
        assertThat(report.get("beneficiariesAddedInPeriod")).isEqualTo(3);
        assertThat(report.get("growthRatePercent")).isEqualTo(100.0);
    }

    @Test
    @DisplayName("Should handle empty results in usage report")
    void shouldHandleEmptyResultsInUsageReport() {
        // Given
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime startDate = now.minusDays(7);
        LocalDateTime endDate = now;
        
        when(beneficiaryRepository.findByCustomerId("CUST999")).thenReturn(Arrays.asList());

        // When
        Map<String, Object> report = beneficiaryService.getBeneficiaryUsageReport(
                "CUST999", startDate, endDate);

        // Then
        assertThat(report).isNotNull();
        assertThat(report.get("totalBeneficiaries")).isEqualTo(0);
        assertThat(report.get("beneficiariesAddedInPeriod")).isEqualTo(0);
        assertThat(report.get("growthRatePercent")).isEqualTo(0.0);
        assertThat(report.get("mostActiveDay")).isNull();
    }

    @Test
    @DisplayName("Should search with date range filters")
    void shouldSearchWithDateRangeFilters() {
        // Given
        LocalDateTime now = LocalDateTime.now();
        searchCriteria.setCreatedAfter(now.minusDays(7));
        searchCriteria.setCreatedBefore(now);
        
        when(beneficiaryRepository.searchBeneficiaries(
                any(), any(), any(), any(), any(), 
                eq(searchCriteria.getCreatedAfter()), 
                eq(searchCriteria.getCreatedBefore()),
                any(), any(), anyInt(), anyInt()
        )).thenReturn(Arrays.asList(testBeneficiaries.get(1), testBeneficiaries.get(2)));
        when(beneficiaryRepository.countBeneficiaries(
                any(), any(), any(), any(), any(), 
                eq(searchCriteria.getCreatedAfter()), 
                eq(searchCriteria.getCreatedBefore())
        )).thenReturn(2L);

        // When
        PagedResponse<Beneficiary> result = beneficiaryService.searchBeneficiaries(searchCriteria);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getContent()).hasSize(2);
        assertThat(result.getTotalElements()).isEqualTo(2);
    }

    @Test
    @DisplayName("Should search with bank code filter")
    void shouldSearchWithBankCodeFilter() {
        // Given
        searchCriteria.setBeneficiaryBankCode("BANK001");
        List<Beneficiary> filteredList = Arrays.asList(testBeneficiaries.get(0), testBeneficiaries.get(2));
        
        when(beneficiaryRepository.searchBeneficiaries(
                any(), any(), any(), any(), eq("BANK001"), any(), any(),
                any(), any(), anyInt(), anyInt()
        )).thenReturn(filteredList);
        when(beneficiaryRepository.countBeneficiaries(
                any(), any(), any(), any(), eq("BANK001"), any(), any()
        )).thenReturn(2L);

        // When
        PagedResponse<Beneficiary> result = beneficiaryService.searchBeneficiaries(searchCriteria);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getContent()).hasSize(2);
        assertThat(result.getContent()).allMatch(b -> "BANK001".equals(b.getBeneficiaryBankCode()));
    }

    @Test
    @DisplayName("Should search with status filter")
    void shouldSearchWithStatusFilter() {
        // Given
        searchCriteria.setStatus("ACTIVE");
        List<Beneficiary> activeBeneficiaries = Arrays.asList(testBeneficiaries.get(0), testBeneficiaries.get(1));
        
        when(beneficiaryRepository.searchBeneficiaries(
                any(), any(), any(), eq("ACTIVE"), any(), any(), any(),
                any(), any(), anyInt(), anyInt()
        )).thenReturn(activeBeneficiaries);
        when(beneficiaryRepository.countBeneficiaries(
                any(), any(), any(), eq("ACTIVE"), any(), any(), any()
        )).thenReturn(2L);

        // When
        PagedResponse<Beneficiary> result = beneficiaryService.searchBeneficiaries(searchCriteria);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getContent()).hasSize(2);
        assertThat(result.getContent()).allMatch(b -> "ACTIVE".equals(b.getStatus()));
    }
}
