/**
 * Generated by GitHub Copilot Agent
 * Issue: #0
 * Date: 2025-12-18
 * NOTE: This test was auto-generated. Review and modify as needed.
 */
package com.alok.payment.beneficiaries.bdd.steps;

import com.alok.payment.beneficiaries.bdd.context.TestContext;
import com.alok.payment.beneficiaries.model.Beneficiary;
import com.alok.payment.beneficiaries.repository.BeneficiaryRepository;
import io.cucumber.datatable.DataTable;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

public class AnalyticsSteps {

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private TestContext testContext;

    @Autowired
    private BeneficiaryRepository beneficiaryRepository;

    @Given("the following beneficiaries exist:")
    public void theFollowingBeneficiariesExist(DataTable dataTable) {
        List<Map<String, String>> rows = dataTable.asMaps();
        LocalDateTime now = LocalDateTime.now();
        
        for (Map<String, String> row : rows) {
            Beneficiary beneficiary = new Beneficiary();
            beneficiary.setCustomerId(row.get("customerId"));
            beneficiary.setAccountNumber("ACC_BDD_" + System.currentTimeMillis());
            beneficiary.setBeneficiaryName(row.get("beneficiaryName"));
            beneficiary.setBeneficiaryAccountNumber("BEN_BDD_" + System.currentTimeMillis() + "_" + Math.random());
            beneficiary.setBeneficiaryBankCode(row.get("beneficiaryBankCode"));
            beneficiary.setBeneficiaryBankName(row.getOrDefault("beneficiaryBankName", "Test Bank"));
            beneficiary.setBeneficiaryType(row.get("beneficiaryType"));
            beneficiary.setStatus(row.get("status"));
            beneficiary.setCreatedAt(now);
            beneficiary.setUpdatedAt(now);
            
            beneficiaryRepository.save(beneficiary);
        }
    }

    @Given("the following beneficiaries exist for customer {string}:")
    public void theFollowingBeneficiariesExistForCustomer(String customerId, DataTable dataTable) {
        List<Map<String, String>> rows = dataTable.asMaps();
        LocalDateTime now = LocalDateTime.now();
        
        for (Map<String, String> row : rows) {
            Beneficiary beneficiary = new Beneficiary();
            beneficiary.setCustomerId(customerId);
            beneficiary.setAccountNumber("ACC_BDD_" + System.currentTimeMillis());
            beneficiary.setBeneficiaryName(row.get("beneficiaryName"));
            beneficiary.setBeneficiaryAccountNumber(row.getOrDefault("beneficiaryAccountNumber", 
                    "BEN_BDD_" + System.currentTimeMillis() + "_" + Math.random()));
            beneficiary.setBeneficiaryBankCode(row.getOrDefault("beneficiaryBankCode", "BANK_BDD"));
            beneficiary.setBeneficiaryBankName(row.getOrDefault("beneficiaryBankName", "Test Bank"));
            beneficiary.setBeneficiaryType(row.get("beneficiaryType"));
            beneficiary.setStatus(row.get("status"));
            beneficiary.setCreatedAt(now);
            beneficiary.setUpdatedAt(now);
            
            beneficiaryRepository.save(beneficiary);
        }
    }

    @Given("the following beneficiaries exist for customer {string} created in the last {int} days:")
    public void theFollowingBeneficiariesExistForCustomerCreatedInLastDays(
            String customerId, int days, DataTable dataTable) {
        List<Map<String, String>> rows = dataTable.asMaps();
        
        for (Map<String, String> row : rows) {
            int daysAgo = Integer.parseInt(row.get("daysAgo"));
            LocalDateTime createdAt = LocalDateTime.now().minusDays(daysAgo);
            
            Beneficiary beneficiary = new Beneficiary();
            beneficiary.setCustomerId(customerId);
            beneficiary.setAccountNumber("ACC_BDD_" + System.currentTimeMillis());
            beneficiary.setBeneficiaryName(row.get("beneficiaryName"));
            beneficiary.setBeneficiaryAccountNumber("BEN_BDD_" + System.currentTimeMillis() + "_" + Math.random());
            beneficiary.setBeneficiaryBankCode("BANK_BDD");
            beneficiary.setBeneficiaryBankName("Test Bank");
            beneficiary.setBeneficiaryType("DOMESTIC");
            beneficiary.setStatus("ACTIVE");
            beneficiary.setCreatedAt(createdAt);
            beneficiary.setUpdatedAt(LocalDateTime.now());
            
            beneficiaryRepository.save(beneficiary);
        }
    }

    @When("I request analytics for customer {string}")
    public void iRequestAnalyticsForCustomer(String customerId) {
        String url = "/api/v1/beneficiaries/analytics/" + customerId;
        
        ResponseEntity<Map<String, Object>> response = restTemplate.exchange(
                url,
                HttpMethod.GET,
                null,
                new ParameterizedTypeReference<Map<String, Object>>() {}
        );
        
        testContext.setResponse(response);
        testContext.setAnalyticsResponse(response.getBody());
    }

    @When("I check for potential duplicates for customer {string}")
    public void iCheckForPotentialDuplicatesForCustomer(String customerId) {
        String url = "/api/v1/beneficiaries/duplicates/" + customerId;
        
        ResponseEntity<List<Map<String, Object>>> response = restTemplate.exchange(
                url,
                HttpMethod.GET,
                null,
                new ParameterizedTypeReference<List<Map<String, Object>>>() {}
        );
        
        testContext.setResponse(response);
        testContext.setDuplicatesResponse(response.getBody());
    }

    @When("I request a usage report for customer {string} for the last {int} days")
    public void iRequestUsageReportForCustomerForLastDays(String customerId, int days) {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime startDate = now.minusDays(days);
        
        String url = String.format("/api/v1/beneficiaries/usage-report/%s?startDate=%s&endDate=%s",
                customerId, startDate, now);
        
        ResponseEntity<Map<String, Object>> response = restTemplate.exchange(
                url,
                HttpMethod.GET,
                null,
                new ParameterizedTypeReference<Map<String, Object>>() {}
        );
        
        testContext.setResponse(response);
        testContext.setAnalyticsResponse(response.getBody());
    }

    @Then("the analytics should show total beneficiaries as {int}")
    public void theAnalyticsShouldShowTotalBeneficiariesAs(int expected) {
        Map<String, Object> analytics = testContext.getAnalyticsResponse();
        assertThat(analytics).isNotNull();
        assertThat(analytics.get("totalBeneficiaries")).isEqualTo(expected);
    }

    @Then("the analytics should show active beneficiaries as {int}")
    public void theAnalyticsShouldShowActiveBeneficiariesAs(int expected) {
        Map<String, Object> analytics = testContext.getAnalyticsResponse();
        assertThat(analytics).isNotNull();
        assertThat(((Number) analytics.get("activeBeneficiaries")).longValue()).isEqualTo((long) expected);
    }

    @Then("the analytics should show inactive beneficiaries as {int}")
    public void theAnalyticsShouldShowInactiveBeneficiariesAs(int expected) {
        Map<String, Object> analytics = testContext.getAnalyticsResponse();
        assertThat(analytics).isNotNull();
        assertThat(((Number) analytics.get("inactiveBeneficiaries")).longValue()).isEqualTo((long) expected);
    }

    @Then("the analytics should show {int} DOMESTIC beneficiaries")
    public void theAnalyticsShouldShowDomesticBeneficiaries(int expected) {
        Map<String, Object> analytics = testContext.getAnalyticsResponse();
        assertThat(analytics).isNotNull();
        
        @SuppressWarnings("unchecked")
        Map<String, Long> byType = (Map<String, Long>) analytics.get("beneficiariesByType");
        assertThat(byType).isNotNull();
        assertThat(byType.get("DOMESTIC")).isEqualTo((long) expected);
    }

    @Then("the analytics should show {int} INTERNATIONAL beneficiaries")
    public void theAnalyticsShouldShowInternationalBeneficiaries(int expected) {
        Map<String, Object> analytics = testContext.getAnalyticsResponse();
        assertThat(analytics).isNotNull();
        
        @SuppressWarnings("unchecked")
        Map<String, Long> byType = (Map<String, Long>) analytics.get("beneficiariesByType");
        assertThat(byType).isNotNull();
        assertThat(byType.get("INTERNATIONAL")).isEqualTo((long) expected);
    }

    @Then("the analytics should show {int} beneficiaries for {string}")
    public void theAnalyticsShouldShowBeneficiariesForBank(int expected, String bankName) {
        Map<String, Object> analytics = testContext.getAnalyticsResponse();
        assertThat(analytics).isNotNull();
        
        @SuppressWarnings("unchecked")
        Map<String, Long> byBank = (Map<String, Long>) analytics.get("beneficiariesByBank");
        assertThat(byBank).isNotNull();
        assertThat(byBank.get(bankName)).isEqualTo((long) expected);
    }

    @Then("the duplicate check should find {int} potential duplicates")
    public void theDuplicateCheckShouldFindPotentialDuplicates(int expected) {
        List<Map<String, Object>> duplicates = testContext.getDuplicatesResponse();
        assertThat(duplicates).isNotNull();
        assertThat(duplicates).hasSize(expected);
    }

    @Then("the duplicate check should find {int} or more potential duplicates")
    public void theDuplicateCheckShouldFindOrMorePotentialDuplicates(int expected) {
        List<Map<String, Object>> duplicates = testContext.getDuplicatesResponse();
        assertThat(duplicates).isNotNull();
        assertThat(duplicates.size()).isGreaterThanOrEqualTo(expected);
    }

    @Then("the duplicates should include {string} and {string}")
    public void theDuplicatesShouldInclude(String name1, String name2) {
        List<Map<String, Object>> duplicates = testContext.getDuplicatesResponse();
        assertThat(duplicates).isNotNull();
        
        boolean foundPair = duplicates.stream().anyMatch(dup -> {
            String ben1Name = (String) dup.get("beneficiary1Name");
            String ben2Name = (String) dup.get("beneficiary2Name");
            return (name1.equals(ben1Name) && name2.equals(ben2Name)) ||
                   (name2.equals(ben1Name) && name1.equals(ben2Name));
        });
        
        assertThat(foundPair).isTrue();
    }

    @Then("the usage report should show total beneficiaries as {int}")
    public void theUsageReportShouldShowTotalBeneficiariesAs(int expected) {
        Map<String, Object> report = testContext.getAnalyticsResponse();
        assertThat(report).isNotNull();
        assertThat(report.get("totalBeneficiaries")).isEqualTo(expected);
    }

    @Then("the usage report should show {int} beneficiaries added in the period")
    public void theUsageReportShouldShowBeneficiariesAddedInPeriod(int expected) {
        Map<String, Object> report = testContext.getAnalyticsResponse();
        assertThat(report).isNotNull();
        assertThat(report.get("beneficiariesAddedInPeriod")).isEqualTo(expected);
    }

    @Then("the usage report should show growth rate as {double} percent")
    public void theUsageReportShouldShowGrowthRateAsPercent(double expected) {
        Map<String, Object> report = testContext.getAnalyticsResponse();
        assertThat(report).isNotNull();
        assertThat(((Number) report.get("growthRatePercent")).doubleValue()).isEqualTo(expected);
    }
}
