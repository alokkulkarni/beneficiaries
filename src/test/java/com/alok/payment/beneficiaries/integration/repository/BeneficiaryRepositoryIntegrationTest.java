/**
 * Generated by GitHub Copilot Agent
 * Issue: #0
 * Date: 2025-12-18
 * NOTE: This test was auto-generated. Review and modify as needed.
 */
package com.alok.payment.beneficiaries.integration.repository;

import com.alok.payment.beneficiaries.model.Beneficiary;
import com.alok.payment.beneficiaries.repository.BeneficiaryRepository;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.images.PullPolicy;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.testcontainers.utility.DockerImageName;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
@Testcontainers
@DisplayName("BeneficiaryRepository Integration Tests")
class BeneficiaryRepositoryIntegrationTest {

    @SuppressWarnings("resource")
    @Container
    static final PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(
            DockerImageName.parse("ghcr.io/alokkulkarni/testcontainers-registry/testcontainers/postgres:16-alpine").asCompatibleSubstituteFor("postgres"))
            .withImagePullPolicy(PullPolicy.defaultPolicy())
            .withDatabaseName("beneficiaries_test")
            .withUsername("test")
            .withPassword("test")
            .withInitScript("init.db");

    @SuppressWarnings("resource")
    @Container
    static final GenericContainer<?> redis = new GenericContainer<>(
            DockerImageName.parse("ghcr.io/alokkulkarni/testcontainers-registry/testcontainers/redis:7-alpine").asCompatibleSubstituteFor("redis"))
            .withImagePullPolicy(PullPolicy.defaultPolicy())
            .withExposedPorts(6379);

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
        registry.add("spring.data.redis.host", redis::getHost);
        registry.add("spring.data.redis.port", redis::getFirstMappedPort);
    }

    @Autowired
    private BeneficiaryRepository beneficiaryRepository;

    @Test
    @DisplayName("Should perform full CRUD operations on beneficiary")
    void shouldPerformFullCrudOperations() {
        // Create
        Beneficiary beneficiary = new Beneficiary();
        beneficiary.setCustomerId("INT_TEST_CUST_001");
        beneficiary.setAccountNumber("INT_TEST_ACC_001");
        beneficiary.setBeneficiaryName("Integration Test Beneficiary");
        beneficiary.setBeneficiaryAccountNumber("INT_TEST_BEN_001");
        beneficiary.setBeneficiaryBankCode("INT_TEST_BANK_001");
        beneficiary.setBeneficiaryBankName("Integration Test Bank");
        beneficiary.setBeneficiaryType("DOMESTIC");
        beneficiary.setStatus("ACTIVE");
        beneficiary.setCreatedAt(LocalDateTime.now());
        beneficiary.setUpdatedAt(LocalDateTime.now());

        Beneficiary saved = beneficiaryRepository.save(beneficiary);
        assertThat(saved.getId()).isNotNull();

        // Read
        Optional<Beneficiary> found = beneficiaryRepository.findByIdAndCustomerId(
                saved.getId(), "INT_TEST_CUST_001");
        assertThat(found).isPresent();
        assertThat(found.get().getBeneficiaryName()).isEqualTo("Integration Test Beneficiary");

        // Update
        saved.setBeneficiaryName("Updated Integration Test Beneficiary");
        saved.setUpdatedAt(LocalDateTime.now());
        Beneficiary updated = beneficiaryRepository.save(saved);
        assertThat(updated.getBeneficiaryName()).isEqualTo("Updated Integration Test Beneficiary");

        // Soft Delete
        int deleted = beneficiaryRepository.softDeleteByIdAndCustomerId(
                saved.getId(), "INT_TEST_CUST_001");
        assertThat(deleted).isEqualTo(1);

        // Verify soft delete
        Optional<Beneficiary> afterDelete = beneficiaryRepository.findByIdAndCustomerId(
                saved.getId(), "INT_TEST_CUST_001");
        assertThat(afterDelete).isEmpty();
    }

    @Test
    @DisplayName("Should search beneficiaries with complex criteria integration test")
    void shouldSearchBeneficiariesWithComplexCriteria() {
        // Create test data
        LocalDateTime now = LocalDateTime.now();
        for (int i = 0; i < 10; i++) {
            Beneficiary b = new Beneficiary();
            b.setCustomerId("SEARCH_INT_TEST_CUST");
            b.setAccountNumber("SEARCH_INT_TEST_ACC");
            b.setBeneficiaryName("Search Test " + (i % 3 == 0 ? "Alpha" : "Beta"));
            b.setBeneficiaryAccountNumber("SEARCH_BEN_" + i);
            b.setBeneficiaryBankCode(i % 2 == 0 ? "SEARCH_BANK_A" : "SEARCH_BANK_B");
            b.setBeneficiaryBankName(i % 2 == 0 ? "Search Bank A" : "Search Bank B");
            b.setBeneficiaryType(i % 2 == 0 ? "DOMESTIC" : "INTERNATIONAL");
            b.setStatus(i < 8 ? "ACTIVE" : "INACTIVE");
            b.setCreatedAt(now.minusDays(10 - i));
            b.setUpdatedAt(now);
            beneficiaryRepository.save(b);
        }

        // Test search with multiple filters
        List<Beneficiary> results = beneficiaryRepository.searchBeneficiaries(
                "SEARCH_INT_TEST_CUST",
                "Alpha",
                "DOMESTIC",
                "ACTIVE",
                "SEARCH_BANK_A",
                now.minusDays(11),
                now.plusDays(1),
                "createdAt",
                "DESC",
                100,
                0
        );

        assertThat(results).isNotEmpty();
        assertThat(results).allMatch(b -> b.getCustomerId().equals("SEARCH_INT_TEST_CUST"));
        assertThat(results).allMatch(b -> b.getBeneficiaryName().contains("Alpha"));
        assertThat(results).allMatch(b -> b.getBeneficiaryType().equals("DOMESTIC"));
        assertThat(results).allMatch(b -> b.getStatus().equals("ACTIVE"));
        assertThat(results).allMatch(b -> b.getBeneficiaryBankCode().equals("SEARCH_BANK_A"));

        // Count should match
        long count = beneficiaryRepository.countBeneficiaries(
                "SEARCH_INT_TEST_CUST",
                "Alpha",
                "DOMESTIC",
                "ACTIVE",
                "SEARCH_BANK_A",
                now.minusDays(11),
                now.plusDays(1)
        );

        assertThat(count).isEqualTo(results.size());
    }

    @Test
    @DisplayName("Should handle pagination correctly in integration test")
    void shouldHandlePaginationCorrectly() {
        // Create test data
        LocalDateTime now = LocalDateTime.now();
        for (int i = 0; i < 15; i++) {
            Beneficiary b = new Beneficiary();
            b.setCustomerId("PAGE_INT_TEST_CUST");
            b.setAccountNumber("PAGE_INT_TEST_ACC");
            b.setBeneficiaryName("Page Test " + i);
            b.setBeneficiaryAccountNumber("PAGE_BEN_" + i);
            b.setBeneficiaryBankCode("PAGE_BANK");
            b.setBeneficiaryBankName("Page Bank");
            b.setBeneficiaryType("DOMESTIC");
            b.setStatus("ACTIVE");
            b.setCreatedAt(now.minusMinutes(15 - i));
            b.setUpdatedAt(now);
            beneficiaryRepository.save(b);
        }

        // Get first page
        List<Beneficiary> page1 = beneficiaryRepository.searchBeneficiaries(
                "PAGE_INT_TEST_CUST", null, null, null, null, null, null,
                "createdAt", "DESC", 5, 0
        );

        // Get second page
        List<Beneficiary> page2 = beneficiaryRepository.searchBeneficiaries(
                "PAGE_INT_TEST_CUST", null, null, null, null, null, null,
                "createdAt", "DESC", 5, 5
        );

        // Get third page
        List<Beneficiary> page3 = beneficiaryRepository.searchBeneficiaries(
                "PAGE_INT_TEST_CUST", null, null, null, null, null, null,
                "createdAt", "DESC", 5, 10
        );

        assertThat(page1).hasSize(5);
        assertThat(page2).hasSize(5);
        assertThat(page3).hasSize(5);

        // Pages should not overlap
        assertThat(page1.get(0).getId()).isNotEqualTo(page2.get(0).getId());
        assertThat(page2.get(0).getId()).isNotEqualTo(page3.get(0).getId());

        // Verify order (DESC by createdAt means most recent first)
        assertThat(page1.get(0).getCreatedAt()).isAfter(page1.get(4).getCreatedAt());
    }

    @Test
    @DisplayName("Should sort beneficiaries by name ascending")
    void shouldSortBeneficiariesByNameAscending() {
        // Create test data with specific names
        LocalDateTime now = LocalDateTime.now();
        String[] names = {"Zara", "Alice", "Mike", "Bob"};
        
        for (String name : names) {
            Beneficiary b = new Beneficiary();
            b.setCustomerId("SORT_INT_TEST_CUST");
            b.setAccountNumber("SORT_INT_TEST_ACC");
            b.setBeneficiaryName(name);
            b.setBeneficiaryAccountNumber("SORT_BEN_" + name);
            b.setBeneficiaryBankCode("SORT_BANK");
            b.setBeneficiaryBankName("Sort Bank");
            b.setBeneficiaryType("DOMESTIC");
            b.setStatus("ACTIVE");
            b.setCreatedAt(now);
            b.setUpdatedAt(now);
            beneficiaryRepository.save(b);
        }

        // Search sorted by name ascending
        List<Beneficiary> results = beneficiaryRepository.searchBeneficiaries(
                "SORT_INT_TEST_CUST", null, null, null, null, null, null,
                "beneficiaryName", "ASC", 100, 0
        );

        assertThat(results).hasSizeGreaterThanOrEqualTo(4);
        
        // Extract the names we inserted
        List<String> resultNames = results.stream()
                .map(Beneficiary::getBeneficiaryName)
                .filter(name -> List.of("Zara", "Alice", "Mike", "Bob").contains(name))
                .toList();

        // Verify alphabetical order
        assertThat(resultNames.get(0)).isEqualTo("Alice");
        assertThat(resultNames.get(1)).isEqualTo("Bob");
        assertThat(resultNames.get(2)).isEqualTo("Mike");
        assertThat(resultNames.get(3)).isEqualTo("Zara");
    }

    @Test
    @DisplayName("Should filter by date range correctly")
    void shouldFilterByDateRangeCorrectly() {
        // Create beneficiaries with specific dates
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime oldDate = now.minusDays(30);
        LocalDateTime recentDate = now.minusDays(5);

        Beneficiary oldBeneficiary = new Beneficiary();
        oldBeneficiary.setCustomerId("DATE_INT_TEST_CUST");
        oldBeneficiary.setAccountNumber("DATE_INT_TEST_ACC");
        oldBeneficiary.setBeneficiaryName("Old Beneficiary");
        oldBeneficiary.setBeneficiaryAccountNumber("DATE_BEN_OLD");
        oldBeneficiary.setBeneficiaryBankCode("DATE_BANK");
        oldBeneficiary.setBeneficiaryBankName("Date Bank");
        oldBeneficiary.setBeneficiaryType("DOMESTIC");
        oldBeneficiary.setStatus("ACTIVE");
        oldBeneficiary.setCreatedAt(oldDate);
        oldBeneficiary.setUpdatedAt(now);
        beneficiaryRepository.save(oldBeneficiary);

        Beneficiary recentBeneficiary = new Beneficiary();
        recentBeneficiary.setCustomerId("DATE_INT_TEST_CUST");
        recentBeneficiary.setAccountNumber("DATE_INT_TEST_ACC");
        recentBeneficiary.setBeneficiaryName("Recent Beneficiary");
        recentBeneficiary.setBeneficiaryAccountNumber("DATE_BEN_RECENT");
        recentBeneficiary.setBeneficiaryBankCode("DATE_BANK");
        recentBeneficiary.setBeneficiaryBankName("Date Bank");
        recentBeneficiary.setBeneficiaryType("DOMESTIC");
        recentBeneficiary.setStatus("ACTIVE");
        recentBeneficiary.setCreatedAt(recentDate);
        recentBeneficiary.setUpdatedAt(now);
        beneficiaryRepository.save(recentBeneficiary);

        // Search for recent beneficiaries only
        List<Beneficiary> results = beneficiaryRepository.searchBeneficiaries(
                "DATE_INT_TEST_CUST",
                null, null, null, null,
                now.minusDays(7),
                now.plusDays(1),
                "createdAt", "DESC", 100, 0
        );

        assertThat(results).isNotEmpty();
        assertThat(results).anyMatch(b -> "Recent Beneficiary".equals(b.getBeneficiaryName()));
        assertThat(results).noneMatch(b -> "Old Beneficiary".equals(b.getBeneficiaryName()));
    }

    @Test
    @DisplayName("Should handle duplicate beneficiary account number detection")
    void shouldHandleDuplicateBeneficiaryAccountNumberDetection() {
        // Create first beneficiary
        Beneficiary b1 = new Beneficiary();
        b1.setCustomerId("DUP_INT_TEST_CUST");
        b1.setAccountNumber("DUP_INT_TEST_ACC");
        b1.setBeneficiaryName("First Beneficiary");
        b1.setBeneficiaryAccountNumber("DUP_BEN_UNIQUE");
        b1.setBeneficiaryBankCode("DUP_BANK");
        b1.setBeneficiaryBankName("Dup Bank");
        b1.setBeneficiaryType("DOMESTIC");
        b1.setStatus("ACTIVE");
        b1.setCreatedAt(LocalDateTime.now());
        b1.setUpdatedAt(LocalDateTime.now());
        beneficiaryRepository.save(b1);

        // Try to find duplicate
        Optional<Beneficiary> duplicate = beneficiaryRepository.findByCustomerIdAndBeneficiaryAccountNumber(
                "DUP_INT_TEST_CUST", "DUP_BEN_UNIQUE");

        assertThat(duplicate).isPresent();
        assertThat(duplicate.get().getBeneficiaryName()).isEqualTo("First Beneficiary");
    }
}
